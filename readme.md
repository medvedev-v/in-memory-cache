# In-Memory Cache with REST API

## Основные фичи

REST API
```text
Используется как интерфейс для удобной, структурированной работы с кэшем
 ```

Синхронизация
```text
Используется sync.RWMutex для обеспечения потокобезопасности

Чтение: множественный одновременный доступ (RLock)

Запись: эксклюзивный доступ (Lock)
 ```

Фоновая очистка
```text
Запускается отдельная горутина при создании кэша

Периодически проверяет и удаляет просроченные записи

Интервал очистки настраивается при создании кэша
 ```

Ограничение размера
```text
При достижении максимального размера удаляется запись с ближайшим временем истечения

Реализована простая стратегия вытеснения на основе TTL
 ```

Формат TTL
```text
Параметр TTL (time-to-live) поддерживает следующие форматы:

300ms - 300 миллисекунд

2s - 2 секунды

5m - 5 минут

1h - 1 час
 ```

## Требования
Go 1.16 или выше

## Установка и запуск

Клонируйте репозиторий:
```console 
git clone <your-repo-url>
cd in-memory-cache
 ```

Запуск сервера:
```console 
go run main.go
 ```
Сервер запустится на порту 8080.

## Использование API

1. Добавление элемента в кэш
Запрос:
```text
PUT /cache/{key}
 ```
Тело запроса:
```json
{
  "value": "любое значение", //помимо string, в том числе типа int, float и иные
  "ttl": "10s" // в формате "300ms", "2s", "5m"
}
```
Пример:
```console 
curl -X PUT -H "Content-Type: application/json" 
\ -d '{"value": "my_value", "ttl": "1m"}' 
\ http://localhost:8080/cache/mykey
 ```

2. Получение значения из кэша по ключу
Запрос:
```text
GET /cache/{key}
 ```
Пример:
```console 
curl http://localhost:8080/cache/mykey
 ```
Ответ:
```json
{
  "value": "my_value",
  "exists": true
}
 ```

3. Удаление значения
Запрос:
```text
DELETE /cache/{key}
 ```
Пример:
```console 
curl -X DELETE http://localhost:8080/cache/mykey
 ```

4. Получение всех ключей
Запрос:
```text
GET /cache
 ```
Пример:
```console 
curl http://localhost:8080/cache
 ```
Ответ:
```json
{
  "keys": ["key1", "key2", "key3"]
}
 ```
